// Generated by CoffeeScript 1.3.3
var BSON, Db, MONGODB_DBNAME, MONGODB_HOST, MONGODB_PORT, Mongo, PORT, SALT, Server, app, async, aws, check_subdomain, configure_app, crypto, db, encrypt_pass, express, formatErrorHandler, fs, mongodb, path, send_email, server, set_cors, _;

express = require("express");

async = require("async");

_ = require("underscore");

formatErrorHandler = function(err, req, res, next) {
  if (err && err.type === "unexpected_token") {
    return res.send(400, {
      error: "Bad request: Invalid JSON"
    });
  } else {
    return next(err);
  }
};

configure_app = function(app) {
  app.configure(function() {
    app.use(express.bodyParser());
    app.use(express.cookieParser());
    app.use(app.router);
    return app.use(formatErrorHandler);
  });
  app.configure("development", function() {
    return app.use(express.errorHandler({
      dumpExceptions: true,
      showStack: true
    }));
  });
  return app.configure("production", function() {
    return app.use(express.errorHandler());
  });
};

app = module.exports = express();

configure_app(app);

mongodb = require("mongodb");

Server = mongodb.Server;

Db = mongodb.Db;

BSON = mongodb.BSONPure;

MONGODB_HOST = process.env.MONGODB_HOST || "localhost";

MONGODB_PORT = parseInt(process.env.MONGODB_PORT || 27017);

MONGODB_DBNAME = process.env.MONGODB_DBNAME || "apidone_dev";

server = new Server(MONGODB_HOST, MONGODB_PORT, {
  auto_reconnect: true
});

db = new Db(MONGODB_DBNAME, server, {
  safe: true
});

db.open(function(err, data) {
  var db_connected;
  db_connected = false;
  if (!err) {
    if (process.env.MONGODB_USER) {
      data.authenticate(process.env.MONGODB_USER, process.env.MONGODB_PASSWORD, function(err2, data2) {
        if (!err2) {
          return db_connected = true;
        } else {
          return console.error("Error: Invalid database user or password");
        }
      });
    } else {
      db_connected = true;
    }
  }
  if (db_connected) {
    return console.log("Connected to '" + MONGODB_DBNAME + "' database");
  } else {
    return console.error("Error: Problem connecting to database");
  }
});

Mongo = {
  get_collection: function(db, name, callback) {
    return db.collection(name, callback);
  },
  insert: function(collection, data, callback) {
    return collection.insert(data, {
      safe: true
    }, callback);
  },
  update_internal_url: function(final_url, _id, collection, callback) {
    var parent_url, resource, resource_id, splited_url;
    splited_url = final_url.split("/");
    resource_id = splited_url[splited_url.length - 1];
    resource = splited_url[splited_url.length - 2];
    parent_url = _.initial(splited_url).join("/");
    return collection.update({
      _id: _id
    }, {
      $set: {
        _internal_url: final_url,
        _internal_parent_url: get_prefix_interal_url(parent_url),
        _internal_parent_resource: get_prefix_interal_url(resource),
        id: resource_id
      }
    }, function(error, doc) {
      return callback(error, final_url, resource_id);
    });
  },
  update: function(collection, selector, query, callback) {
    return collection.update(selector, query, callback);
  },
  get_collections: function(db, subdomain, callback) {
    return db.collectionNames(function(err, collections) {
      var collection, collection_start, collections_return, db_name, i;
      collections_return = [];
      db_name = process.env.MONGODB_DBNAME || "apidone_dev";
      collection = subdomain + "___";
      collection_start = db_name + "." + collection;
      i = collections.length - 1;
      while (i >= 0) {
        if (collections[i]["name"].indexOf(collection_start) === 0) {
          collections_return.push({
            name: collections[i]["name"].replace(collection_start, "")
          });
        }
        i--;
      }
      return callback(err, collections_return);
    });
  }
};

aws = require('aws-lib');

fs = require('fs');

path = require('path');

send_email = function(recipient_email, apidone_url, template, callback) {
  var ses;
  console.log("sending email to " + recipient_email);
  if (process.env.AWS_SES_ACCESS) {
    console.log("access");
    ses = aws.createSESClient(process.env.AWS_SES_ACCESS, process.env.AWS_SES_SECRET);
    return fs.readFile(path.resolve(__dirname, "../templates/email/" + template + "/html.html"), 'UTF-8', function(err, html) {
      var send_args;
      html = html.replace("___apidone_url___", apidone_url);
      send_args = {
        'Destination.ToAddresses.member.1': recipient_email,
        'Message.Body.Html.Charset': 'UTF-8',
        'Message.Body.Html.Data': html,
        'Message.Subject.Charset': 'UTF-8',
        'Message.Subject.Data': 'Welcome to APIdone.com',
        'Source': 'info@apidone.com'
      };
      try {
        return ses.call('SendEmail', send_args, callback);
      } catch (e) {
        console.err("ERROR sending email to " + recipient_email);
        console.err(e);
        return callback(e, null);
      }
    });
  } else {
    console.log("Omitting email for " + recipient_email);
    return callback(null, null);
  }
};

crypto = require('crypto');

SALT = 'Esto es lo mejor que se me ocurrio como salt';

set_cors = function(response) {
  response.header("Access-Control-Allow-Origin", "*");
  response.header("Access-Control-Allow-Headers", "X-Requested-With,Content-Type,Origin,Accept");
  return response.header("Access-Control-Allow-Methods", "OPTIONS,GET,HEAD,POST,PUT,DELETE");
};

app.all("/*", function(request, response, next) {
  var as_cookie;
  as_cookie = request.cookies.as;
  request.account = null;
  set_cors(response);
  if (as_cookie) {
    return Mongo.get_collection(db, 'accounts', function(err, collection) {
      return collection.findOne({
        sessions: as_cookie
      }, function(err, account_exists) {
        request.account = account_exists;
        return next();
      });
    });
  } else {
    return next();
  }
});

app.options("/*", function(request, response) {
  return response.send("");
});

check_subdomain = function(collection, subdomain, callback) {
  return collection.findOne({
    'subdomains': subdomain
  }, function(err, account) {
    if (err) {
      return callback(err, null);
    } else if (account && account.subdomain) {
      return callback(null, 'Not Available');
    } else {
      return callback(null, 'Available');
    }
  });
};

encrypt_pass = function(pass) {
  var shasum;
  shasum = crypto.createHash('sha1');
  shasum.update(SALT + pass);
  return shasum.digest('hex');
};

app.get("/subdomains", function(request, response) {
  if (request.account) {
    return response.send(request.account.subdomains);
  } else {
    response.statusCode = 401;
    return response.send({
      'code': 401,
      'err': 'Unauthorized.'
    });
  }
});

app.post("/subdomains", function(request, response) {
  if (!request.body.subdomain) {
    response.statusCode = 400;
    return response.send({
      'err': 'Bad Request'
    });
  } else {
    return Mongo.get_collection(db, 'accounts', function(err, collection) {
      return check_subdomain(collection, request.body.subdomain, function(err, status) {
        if (err) {
          response.statusCode = 400;
          return response.send({
            'err': 'Bad Request'
          });
        } else {
          response.statusCode = 200;
          return response.send({
            'status': status
          });
        }
      });
    });
  }
});

app.post("/accounts", function(request, response) {
  return async.waterfall([
    async.apply(Mongo.get_collection, db, 'accounts'), function(collection, callback) {
      if (request.body.email && request.body.pass && request.body.subdomain) {
        return collection.findOne({
          email: request.body.email
        }, function(err, account_exists) {
          if (err) {
            return callback({
              'code': 500,
              'err': 'Ups. something unespected happend.'
            }, null);
          } else if (account_exists) {
            return callback({
              'code': 409,
              'err': 'User already has an account.'
            }, null);
          } else {
            return check_subdomain(collection, request.body.subdomain, function(err, status) {
              if (err) {
                return callback({
                  'code': 500,
                  'err': 'Ups. something unespected happend.'
                }, null);
              } else if (status === 'Available') {
                request.body.pass = encrypt_pass(request.body.pass);
                request.body['subdomains'] = [request.body.subdomain];
                request.body['sessions'] = [];
                delete request.body['subdomain'];
                return Mongo.insert(collection, request.body, function(err, inserted_account) {
                  return callback(err, request.body['subdomains'][0]);
                });
              } else {
                return callback({
                  'code': 409,
                  'err': 'You have to choose another subdomain.'
                }, null);
              }
            });
          }
        });
      } else {
        return callback({
          'code': 400,
          'err': 'You have to fill all the fields.'
        }, null);
      }
    }
  ], function(err, subdomain) {
    if (err) {
      if (err.code) {
        response.statusCode = err.code;
        return response.send(err);
      } else {
        response.statusCode = 503;
        return response.send("Internal Server Error");
      }
    } else {
      return send_email(request.body.email, "http://" + subdomain + ".apidone.com", 'welcome', function(err, result) {
        response.statusCode = 201;
        return response.send({
          id: subdomain
        });
      });
    }
  });
});

app.post("/login", function(request, response) {
  return async.waterfall([
    async.apply(Mongo.get_collection, db, 'accounts'), function(collection, callback) {
      if (request.body.email && request.body.pass) {
        return collection.findOne({
          email: request.body.email,
          pass: encrypt_pass(request.body.pass)
        }, function(err, account_exists) {
          if (err) {
            return callback({
              'code': 500,
              'err': 'Ups. something unespected happend.'
            }, null);
          } else {
            if (account_exists) {
              return crypto.randomBytes(48, function(ex, buf) {
                var session;
                session = buf.toString('hex');
                account_exists.sessions.push(session);
                return collection.save(account_exists, function(err, update_response) {
                  return callback(null, session);
                });
              });
            } else {
              return callback({
                'code': 401,
                'err': 'Unauthorized.'
              }, null);
            }
          }
        });
      } else {
        return callback({
          'code': 400,
          'err': 'To login you have to send the email and password.'
        }, null);
      }
    }
  ], function(err, session) {
    if (err) {
      if (err.code) {
        response.statusCode = err.code;
        return response.send(err);
      } else {
        response.statusCode = 503;
        return response.send("Internal Server Error");
      }
    } else {
      response.statusCode = 201;
      response.cookie('as', session, {
        path: '/',
        expires: new Date(Date.now() + 60 * 60 * 24 * 31 * 1000)
      });
      return response.send({
        "status": "OK"
      });
    }
  });
});

app.get("/amazon_lb", function(request, response) {
  response.statusCode = 200;
  return response.send({
    "status": "OK"
  });
});

if (!module.parent) {
  PORT = process.env.APIDONE_PORT || process.env.PORT || 3000;
  app.listen(PORT);
  console.log("Express server listening on port %d in %s mode", PORT, app.settings.env);
}
